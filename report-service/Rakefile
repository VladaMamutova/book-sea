# Add your own tasks in files placed in lib/tasks ending in .rake,
# for example lib/tasks/capistrano.rake, and they will automatically be available to Rake.

require_relative 'config/application'

require 'sneakers/tasks'

Rails.application.load_tasks

# namespace :rabbitmq do
#   # The rake task initializes the connection between apps throughout RabbitMQ.
#   desc 'Connect consumer to producer'
#   task :setup do
#     require "bunny"

#     # connection = Bunny.new(
#     #   host:  'localhost',
#     #   port:  '15672',
#     #   vhost: '/',
#     #   user:  'guest',
#     #   pass:  'guest'
#     # )

#     #connection = Bunny.new('amqp://guest:guest@rabbitmq')
#     #connection = Bunny.new('amqp://guest:guest@localhost:15672')
#     connection.start

#     channel = connection.create_channel
#     queue_taken_books = channel.queue("taken_books", auto_delete: true)

#     #queue_restaurants.bind("crawler.restaurants")
#     connection.close
#   end
# end

# namespace :rabbitmq do
#   desc "Setup routing"
#   task :setup do
#     require "bunny"

#     conn = Bunny.new
#     conn.start

#     ch = conn.create_channel

#     # get or create exchange
#     x = ch.fanout("blog.posts")

#     # get or create queue (note the durable setting)
#     queue = ch.queue("dashboard.posts", durable: true)

#     # bind queue to exchange
#     queue.bind("blog.posts")

#     conn.close
#   end
# end

# EventMachine.run do
#   connection = Bunny.new('amqp://guest:guest@rabbitmq')
#   connection.start
#   channel = connection.create_channel
#   queue = channel.queue('vm.control', auto_delete: true)
#   queue.subscribe do |_delivery_info, _metadata, payload|
#   really_slow_task(payload)
#   end
#   Signal.trap('INT') do
#   puts 'exiting INT'
#   connection.close { EventMachine.stop }
#   end
#   Signal.trap('TERM') do
#   puts 'killing TERM'
#   connection.close { EventMachine.stop }
#   end
#   end